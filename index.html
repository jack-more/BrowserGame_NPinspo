<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft-Style Browser Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
        #hud {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #blockSelector {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: flex;
            gap: 5px;
        }
        .block-option {
            width: 40px;
            height: 40px;
            cursor: pointer;
            border: 2px solid transparent;
            background-size: cover;
            image-rendering: pixelated;
        }
        .block-option.selected {
            border: 2px solid white;
        }
        #instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #loadingBar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
        }
        #loadingBarFill {
            height: 100%;
            width: 0%;
            background: #8BC34A;
            border-radius: 10px;
            transition: width 0.3s;
        }
        #errorMessage {
            color: red;
            margin-top: 10px;
            max-width: 80%;
            text-align: center;
        }
        #startButton {
            margin-top: 20px;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="crosshair">+</div>
    <div id="hud">Position: <span id="position">0, 0, 0</span></div>
    <div id="blockSelector">
        <!-- Block options will be added dynamically -->
    </div>
    <div id="instructions">
        WASD: Move<br>
        Mouse: Look<br>
        Click: Place/Break blocks<br>
        Space: Jump<br>
        Shift: Break block<br>
        E: Toggle block selector
    </div>
    <div id="loading">
        <h2>Loading Minecraft-Style World</h2>
        <div id="loadingBar">
            <div id="loadingBarFill"></div>
        </div>
        <p id="loadingText">Preparing terrain...</p>
        <div id="errorMessage"></div>
        <button id="startButton">Start Anyway</button>
    </div>

    <!-- Import Three.js - All from same CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, controls;
        let world = {};
        let blockGeometry, blockMaterials = {};
        let raycaster, mouse;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let playerHeight = 1.6;
        let gravity = 30;
        let jumpStrength = 10;
        let playerSpeed = 10;
        let cubeSize = 1;
        let selectedBlockType = 'grass';
        let errorOccurred = false;
        
        // Block colors for when textures fail to load
        const blockColors = {
            grass: 0x7CFC00, // Bright green
            dirt: 0x8B4513,  // Brown
            stone: 0x808080, // Gray
            sand: 0xFFD700,  // Gold
            wood: 0xA0522D,  // Sienna
            leaves: 0x228B22  // Forest green
        };

        // Implement PointerLockControls manually since loading it might fail
        class PointerLockControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                
                this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
                this.vec = new THREE.Vector3();
                
                this.onMouseMoveBound = this.onMouseMove.bind(this);
                this.onPointerlockChangeBound = this.onPointerlockChange.bind(this);
                
                this.connect();
            }
            
            connect() {
                document.addEventListener('mousemove', this.onMouseMoveBound);
                document.addEventListener('pointerlockchange', this.onPointerlockChangeBound);
            }
            
            disconnect() {
                document.removeEventListener('mousemove', this.onMouseMoveBound);
                document.removeEventListener('pointerlockchange', this.onPointerlockChangeBound);
            }
            
            lock() {
                this.domElement.requestPointerLock();
            }
            
            unlock() {
                document.exitPointerLock();
            }
            
            onPointerlockChange() {
                this.isLocked = document.pointerLockElement === this.domElement;
            }
            
            onMouseMove(event) {
                if (!this.isLocked) return;
                
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                this.euler.setFromQuaternion(this.camera.quaternion);
                
                this.euler.y -= movementX * 0.002;
                this.euler.x -= movementY * 0.002;
                
                this.euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.euler.x));
                
                this.camera.quaternion.setFromEuler(this.euler);
            }
            
            moveRight(distance) {
                this.vec.setFromMatrixColumn(this.camera.matrix, 0);
                this.camera.position.addScaledVector(this.vec, distance);
            }
            
            moveForward(distance) {
                this.vec.setFromMatrixColumn(this.camera.matrix, 0);
                this.vec.crossVectors(this.camera.up, this.vec);
                this.camera.position.addScaledVector(this.vec, distance);
            }
        }
        
        // Create a fallback texture with a colored pattern
        function createFallbackTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            // Fill with base color
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.fillRect(0, 0, 16, 16);
            
            // Add a grid pattern
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, 8);
            ctx.lineTo(16, 8);
            ctx.moveTo(8, 0);
            ctx.lineTo(8, 16);
            ctx.stroke();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // Create materials for each block type using colors
        function createColorBlockMaterials() {
            const materials = {};
            
            for (const [blockType, color] of Object.entries(blockColors)) {
                const texture = createFallbackTexture(color);
                
                materials[blockType] = [
                    new THREE.MeshLambertMaterial({ map: texture }), // right
                    new THREE.MeshLambertMaterial({ map: texture }), // left
                    new THREE.MeshLambertMaterial({ map: texture }), // top
                    new THREE.MeshLambertMaterial({ map: texture }), // bottom
                    new THREE.MeshLambertMaterial({ map: texture }), // front
                    new THREE.MeshLambertMaterial({ map: texture })  // back
                ];
            }
            
            return materials;
        }

        // Update loading bar
        function updateLoadingBar(percentage) {
            document.getElementById('loadingBarFill').style.width = `${Math.min(100, percentage * 100)}%`;
        }

        // Display error message
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorOccurred = true;
            
            // Show the start button to bypass the error
            document.getElementById('startButton').style.display = 'block';
        }

        // Initialize Three.js scene
        async function init() {
            try {
                // Prepare fallback materials first
                blockMaterials = createColorBlockMaterials();
                
                document.getElementById('loadingText').textContent = 'Setting up 3D world...';
                updateLoadingBar(0.3);
                
                // Create a scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x87CEEB); // Sky blue color
                
                // Create a fog effect
                scene.fog = new THREE.Fog(0x87CEEB, 50, 100);
                
                // Create a perspective camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.y = playerHeight;
                
                // Create a renderer
                renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                
                // Add pointer lock controls
                controls = new PointerLockControls(camera, document.body);
                
                // Setup click to start
                document.addEventListener('click', () => {
                    if (!controls.isLocked) {
                        controls.lock();
                    }
                });
                
                // Handle pointer lock state changes
                document.addEventListener('pointerlockchange', () => {
                    const instructionsElement = document.getElementById('instructions');
                    if (document.pointerLockElement === document.body) {
                        instructionsElement.style.display = 'none';
                    } else {
                        instructionsElement.style.display = 'block';
                    }
                });
                
                // Add lights to the scene
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 0.5).normalize();
                scene.add(directionalLight);
                
                // Set up raycaster for block interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Create a cube geometry for blocks
                blockGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                
                updateLoadingBar(0.5);
                
                // Generate terrain
                await generateTerrain();
                
                // Set up block selector
                setupBlockSelector();
                
                // Add event listeners
                setupEventListeners();
                
                updateLoadingBar(1.0);
                
                // Hide loading screen
                document.getElementById('loading').style.display = 'none';
                
                // Start animation loop
                animate();
            } catch (error) {
                console.error("Error initializing game:", error);
                showError("There was an error initializing the game. You can try starting anyway, but some features may not work properly.");
            }
        }
        
        // Generate terrain using a simpler method
        async function generateTerrain() {
            document.getElementById('loadingText').textContent = 'Generating terrain...';
            
            const worldSize = 32; // Smaller world size for better performance
            const worldHeight = 16; // Maximum height of the terrain
            
            // Helper function for noise
            function noise(x, z) {
                return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 0.5 + 0.5; 
            }
            
            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    // Update loading progress occasionally
                    if ((x * worldSize + z) % 200 === 0) {
                        updateLoadingBar(0.5 + 0.5 * ((x * worldSize + z) / (worldSize * worldSize)));
                        // Allow UI to update
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    // Generate height using simple noise function
                    const height = Math.floor(noise(x, z) * 8) + 1;
                    
                    // Place blocks based on height
                    for (let y = 0; y < height; y++) {
                        let blockType;
                        if (y === height - 1) {
                            blockType = 'grass';
                        } else if (y > height - 4) {
                            blockType = 'dirt';
                        } else {
                            blockType = 'stone';
                        }
                        
                        createBlock(x - worldSize/2, y, z - worldSize/2, blockType);
                    }
                    
                    // Randomly add trees (less frequently)
                    if (Math.random() < 0.005) {
                        createTree(x - worldSize/2, height, z - worldSize/2);
                    }
                }
            }
        }
        
        // Create a tree at the specified position
        function createTree(x, y, z) {
            const trunkHeight = 3 + Math.floor(Math.random() * 2);
            
            // Create trunk
            for (let i = 0; i < trunkHeight; i++) {
                createBlock(x, y + i, z, 'wood');
            }
            
            // Create leaves
            const leafSize = 2;
            for (let lx = -leafSize; lx <= leafSize; lx++) {
                for (let ly = 0; ly <= leafSize; ly++) {
                    for (let lz = -leafSize; lz <= leafSize; lz++) {
                        // Skip trunk positions
                        if (lx === 0 && lz === 0 && ly < trunkHeight - 1) continue;
                        
                        // Make leaves roughly spherical
                        const distance = Math.sqrt(lx*lx + ly*ly + lz*lz);
                        if (distance <= leafSize + 0.5) {
                            createBlock(x + lx, y + trunkHeight - 1 + ly, z + lz, 'leaves');
                        }
                    }
                }
            }
        }
        
        // Create a block at the specified position
        function createBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            
            // Check if block already exists
            if (world[key]) return;
            
            // Create a mesh for the block
            const materials = blockMaterials[type];
            const mesh = new THREE.Mesh(blockGeometry, materials);
            mesh.position.set(x * cubeSize + cubeSize/2, y * cubeSize + cubeSize/2, z * cubeSize + cubeSize/2);
            mesh.userData = { type, x, y, z };
            
            // Add to scene and store in world object
            scene.add(mesh);
            world[key] = mesh;
        }
        
        // Remove a block at the specified position
        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = world[key];
            
            if (block) {
                scene.remove(block);
                delete world[key];
            }
        }
        
        // Set up block selector
        function setupBlockSelector() {
            const blockSelector = document.getElementById('blockSelector');
            blockSelector.innerHTML = ''; // Clear any existing content
            
            for (const [type, _] of Object.entries(blockColors)) {
                const blockOption = document.createElement('div');
                blockOption.className = 'block-option';
                blockOption.dataset.type = type;
                blockOption.style.backgroundColor = '#' + blockColors[type].toString(16).padStart(6, '0');
                
                if (type === selectedBlockType) {
                    blockOption.classList.add('selected');
                }
                
                blockOption.addEventListener('click', () => {
                    document.querySelectorAll('.block-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    blockOption.classList.add('selected');
                    selectedBlockType = type;
                });
                
                blockSelector.appendChild(blockOption);
            }
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space':
                        if (canJump) {
                            velocity.y = jumpStrength;
                            canJump = false;
                        }
                        break;
                    case 'KeyE':
                        const blockSelector = document.getElementById('blockSelector');
                        blockSelector.style.display = blockSelector.style.display === 'none' ? 'flex' : 'none';
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
            
            // Mouse click for block interaction
            document.addEventListener('mousedown', (event) => {
                if (!controls.isLocked) return;
                
                // Cast ray from camera
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                // Get intersections with blocks
                const intersects = raycaster.intersectObjects(Object.values(world));
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const block = intersect.object;
                    
                    if (event.button === 0) {  // Left click - remove block
                        removeBlock(block.userData.x, block.userData.y, block.userData.z);
                    } else if (event.button === 2) {  // Right click - add block
                        // Calculate position for new block based on face normal
                        const faceIndex = Math.floor(intersect.faceIndex / 2);
                        const normal = [
                            new THREE.Vector3(1, 0, 0),
                            new THREE.Vector3(-1, 0, 0),
                            new THREE.Vector3(0, 1, 0),
                            new THREE.Vector3(0, -1, 0),
                            new THREE.Vector3(0, 0, 1),
                            new THREE.Vector3(0, 0, -1)
                        ][faceIndex];
                        
                        // Calculate position for new block
                        const x = block.userData.x + normal.x;
                        const y = block.userData.y + normal.y;
                        const z = block.userData.z + normal.z;
                        
                        // Check if position is valid (not inside player)
                        const playerPos = new THREE.Vector3(
                            Math.floor(camera.position.x / cubeSize),
                            Math.floor(camera.position.y / cubeSize),
                            Math.floor(camera.position.z / cubeSize)
                        );
                        
                        const playerHeadPos = new THREE.Vector3(
                            playerPos.x,
                            playerPos.y + 1,
                            playerPos.z
                        );
                        
                        if (x !== playerPos.x || y !== playerPos.y || z !== playerPos.z) {
                            if (x !== playerHeadPos.x || y !== playerHeadPos.y || z !== playerHeadPos.z) {
                                createBlock(x, y, z, selectedBlockType);
                            }
                        }
                    }
                }
            });
            
            // Prevent context menu on right click
            document.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Start button click handler
            document.getElementById('startButton').addEventListener('click', () => {
                document.getElementById('loading').style.display = 'none';
                animate();
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            // Apply gravity
            velocity.y -= gravity * delta;
            
            // Get movement direction
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            // Calculate velocity based on inputs
            if (moveForward || moveBackward) velocity.z = -direction.z * playerSpeed;
            else velocity.z = 0;
            
            if (moveLeft || moveRight) velocity.x = -direction.x * playerSpeed;
            else velocity.x = 0;
            
            // Apply movement
            controls.moveRight(velocity.x * delta);
            controls.moveForward(velocity.z * delta);
            
            // Apply gravity and check for ground collision
            camera.position.y += velocity.y * delta;
            
            // Check collision with ground
            const playerPos = new THREE.Vector3(
                Math.floor(camera.position.x / cubeSize),
                Math.floor((camera.position.y - playerHeight/2) / cubeSize),
                Math.floor(camera.position.z / cubeSize)
            );
            
            // Check if block exists below player
            const blockBelow = world[`${playerPos.x},${playerPos.y - 1},${playerPos.z}`];
            
            if (blockBelow && camera.position.y - playerHeight/2 <= (playerPos.y * cubeSize + cubeSize)) {
                velocity.y = 0;
                camera.position.y = playerPos.y * cubeSize + cubeSize + playerHeight/2;
                canJump = true;
            }
            
            // Prevent falling through the world
            if (camera.position.y < -50) {
                camera.position.set(0, 50, 0);
                velocity.set(0, 0, 0);
            }
            
            // Update HUD
            document.getElementById('position').textContent = 
                `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
            
            // Render scene
            renderer.render(scene, camera);
            
            prevTime = time;
        }
        
        // Handle errors
        window.addEventListener('error', (event) => {
            showError(`Error: ${event.message}`);
        });
        
        // Start the game
        init().catch(error => {
            console.error("Fatal error:", error);
            showError(`Fatal error: ${error.message || 'Unknown error'}`);
        });
    </script>
</body>
</html>
