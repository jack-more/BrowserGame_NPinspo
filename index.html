<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft-Style Browser Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 100;
        }
        #hud {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #blockSelector {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: flex;
            gap: 5px;
        }
        .block-option {
            width: 40px;
            height: 40px;
            cursor: pointer;
            border: 2px solid transparent;
            background-size: cover;
            image-rendering: pixelated;
        }
        .block-option.selected {
            border: 2px solid white;
        }
        #instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #loadingBar {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 20px;
        }
        #loadingBarFill {
            height: 100%;
            width: 0%;
            background: #8BC34A;
            border-radius: 10px;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="crosshair">+</div>
    <div id="hud">Position: <span id="position">0, 0, 0</span></div>
    <div id="blockSelector">
        <!-- Block options will be added dynamically -->
    </div>
    <div id="instructions">
        WASD: Move<br>
        Mouse: Look<br>
        Click: Place/Break blocks<br>
        Space: Jump<br>
        Shift: Break block<br>
        E: Toggle block selector
    </div>
    <div id="loading">
        <h2>Loading Minecraft-Style World</h2>
        <div id="loadingBar">
            <div id="loadingBarFill"></div>
        </div>
        <p id="loadingText">Preparing terrain...</p>
    </div>

    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // Game variables
        let scene, camera, renderer, controls;
        let world = {};
        let blockGeometry, blockMaterials = {};
        let raycaster, mouse;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let playerHeight = 1.6;
        let gravity = 30;
        let jumpStrength = 10;
        let playerSpeed = 10;
        let cubeSize = 1;
        let selectedBlockType = 'grass';
        
        // Textures for different block types
        const textureURLs = {
            dirt: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/dirt.png',
            grass_top: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/grass_top.png',
            grass_side: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/grass_side.png',
            stone: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/stone.png',
            sand: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/sand.png',
            log_side: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/log_oak.png',
            log_top: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/log_oak_top.png',
            leaves: 'https://raw.githubusercontent.com/greggman/webgl-fundamentals/master/webgl/lessons/resources/images/minecraft/leaves_oak.png'
        };

        // Block types data
        const blockTypes = {
            grass: {
                name: 'Grass',
                textures: {
                    top: 'grass_top',
                    bottom: 'dirt',
                    sides: 'grass_side'
                }
            },
            dirt: {
                name: 'Dirt',
                textures: {
                    all: 'dirt'
                }
            },
            stone: {
                name: 'Stone',
                textures: {
                    all: 'stone'
                }
            },
            sand: {
                name: 'Sand',
                textures: {
                    all: 'sand'
                }
            },
            wood: {
                name: 'Wood',
                textures: {
                    top: 'log_top',
                    bottom: 'log_top',
                    sides: 'log_side'
                }
            },
            leaves: {
                name: 'Leaves',
                textures: {
                    all: 'leaves'
                }
            }
        };

        // Load textures
        function loadTextures() {
            const textureLoader = new THREE.TextureLoader();
            const loadedTextures = {};
            let totalTextures = Object.keys(textureURLs).length;
            let loadedCount = 0;

            return new Promise((resolve) => {
                for (const [name, url] of Object.entries(textureURLs)) {
                    textureLoader.load(url, (texture) => {
                        // Apply pixelated texture filtering
                        texture.magFilter = THREE.NearestFilter;
                        texture.minFilter = THREE.NearestFilter;
                        loadedTextures[name] = texture;
                        
                        loadedCount++;
                        updateLoadingBar(loadedCount / totalTextures * 0.2); // 20% of loading is textures
                        
                        if (loadedCount === totalTextures) {
                            resolve(loadedTextures);
                        }
                    });
                }
            });
        }

        // Create materials for each block type
        function createBlockMaterials(textures) {
            const materials = {};

            // Process each block type
            for (const [blockType, blockData] of Object.entries(blockTypes)) {
                if (blockData.textures.all) {
                    // Same texture on all sides
                    const texture = textures[blockData.textures.all];
                    materials[blockType] = [
                        new THREE.MeshLambertMaterial({ map: texture }), // right
                        new THREE.MeshLambertMaterial({ map: texture }), // left
                        new THREE.MeshLambertMaterial({ map: texture }), // top
                        new THREE.MeshLambertMaterial({ map: texture }), // bottom
                        new THREE.MeshLambertMaterial({ map: texture }), // front
                        new THREE.MeshLambertMaterial({ map: texture })  // back
                    ];
                } else {
                    // Different textures for different sides
                    const top = textures[blockData.textures.top];
                    const bottom = textures[blockData.textures.bottom || blockData.textures.top];
                    const sides = textures[blockData.textures.sides || blockData.textures.top];
                    
                    materials[blockType] = [
                        new THREE.MeshLambertMaterial({ map: sides }), // right
                        new THREE.MeshLambertMaterial({ map: sides }), // left
                        new THREE.MeshLambertMaterial({ map: top }),   // top
                        new THREE.MeshLambertMaterial({ map: bottom }), // bottom
                        new THREE.MeshLambertMaterial({ map: sides }), // front
                        new THREE.MeshLambertMaterial({ map: sides })  // back
                    ];
                }
            }

            return materials;
        }

        // Update loading bar
        function updateLoadingBar(percentage) {
            document.getElementById('loadingBarFill').style.width = `${Math.min(100, percentage * 100)}%`;
        }

        // Initialize Three.js scene
        async function init() {
            // Load textures first
            document.getElementById('loadingText').textContent = 'Loading textures...';
            const textures = await loadTextures();
            
            // Set up block materials
            blockMaterials = createBlockMaterials(textures);

            document.getElementById('loadingText').textContent = 'Setting up 3D world...';
            
            // Create a scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue color
            
            // Create a fog effect
            scene.fog = new THREE.Fog(0x87CEEB, 50, 100);
            
            // Create a perspective camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerHeight;
            
            // Create a renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Add pointer lock controls for mouse look
            controls = new THREE.PointerLockControls(camera, document.body);
            
            // Setup click to start
            document.addEventListener('click', () => {
                if (!controls.isLocked) {
                    controls.lock();
                }
            });
            
            // Handle pointer lock state changes
            controls.addEventListener('lock', () => {
                document.getElementById('instructions').style.display = 'none';
            });
            
            controls.addEventListener('unlock', () => {
                document.getElementById('instructions').style.display = 'block';
            });
            
            // Add lights to the scene
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0.5).normalize();
            scene.add(directionalLight);
            
            // Set up raycaster for block interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Create a cube geometry for blocks
            blockGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            
            // Generate terrain
            await generateTerrain();
            
            // Set up block selector
            setupBlockSelector();
            
            // Add event listeners
            setupEventListeners();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            
            // Start animation loop
            animate();
        }
        
        // Generate terrain using simplex noise
        async function generateTerrain() {
            document.getElementById('loadingText').textContent = 'Generating terrain...';
            
            const simplex = new SimplexNoise();
            const worldSize = 64; // Size of the world
            const worldHeight = 32; // Maximum height of the terrain
            
            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    // Update loading progress
                    if ((x * worldSize + z) % 100 === 0) {
                        updateLoadingBar(0.2 + 0.8 * ((x * worldSize + z) / (worldSize * worldSize)));
                        // Allow UI to update
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    // Generate height using simplex noise
                    const height = Math.floor(
                        (simplex.noise2D(x / 16, z / 16) * 0.5 + 0.5) * 10 + 
                        (simplex.noise2D(x / 8, z / 8) * 0.25 + 0.25) * 4
                    );
                    
                    // Place blocks based on height
                    for (let y = 0; y < height; y++) {
                        let blockType;
                        if (y === height - 1) {
                            blockType = 'grass';
                        } else if (y > height - 4) {
                            blockType = 'dirt';
                        } else {
                            blockType = 'stone';
                        }
                        
                        createBlock(x - worldSize/2, y, z - worldSize/2, blockType);
                    }
                    
                    // Randomly add trees
                    if (Math.random() < 0.01) {
                        createTree(x - worldSize/2, height, z - worldSize/2);
                    }
                }
            }
        }
        
        // Create a tree at the specified position
        function createTree(x, y, z) {
            const trunkHeight = 4 + Math.floor(Math.random() * 3);
            
            // Create trunk
            for (let i = 0; i < trunkHeight; i++) {
                createBlock(x, y + i, z, 'wood');
            }
            
            // Create leaves
            const leafSize = 2;
            for (let lx = -leafSize; lx <= leafSize; lx++) {
                for (let ly = 0; ly <= leafSize + 1; ly++) {
                    for (let lz = -leafSize; lz <= leafSize; lz++) {
                        // Skip trunk positions
                        if (lx === 0 && lz === 0 && ly < trunkHeight - 1) continue;
                        
                        // Make leaves roughly spherical
                        const distance = Math.sqrt(lx*lx + ly*ly + lz*lz);
                        if (distance <= leafSize + 0.5 + Math.random() * 0.5) {
                            createBlock(x + lx, y + trunkHeight - 1 + ly, z + lz, 'leaves');
                        }
                    }
                }
            }
        }
        
        // Create a block at the specified position
        function createBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            
            // Check if block already exists
            if (world[key]) return;
            
            // Create a mesh for the block
            const materials = blockMaterials[type];
            const mesh = new THREE.Mesh(blockGeometry, materials);
            mesh.position.set(x * cubeSize + cubeSize/2, y * cubeSize + cubeSize/2, z * cubeSize + cubeSize/2);
            mesh.userData = { type, x, y, z };
            
            // Add to scene and store in world object
            scene.add(mesh);
            world[key] = mesh;
        }
        
        // Remove a block at the specified position
        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            const block = world[key];
            
            if (block) {
                scene.remove(block);
                delete world[key];
            }
        }
        
        // Set up block selector
        function setupBlockSelector() {
            const blockSelector = document.getElementById('blockSelector');
            
            for (const [type, data] of Object.entries(blockTypes)) {
                const blockOption = document.createElement('div');
                blockOption.className = 'block-option';
                blockOption.dataset.type = type;
                
                // Use the correct texture for the display
                let textureKey;
                if (data.textures.all) {
                    textureKey = data.textures.all;
                } else if (data.textures.top) {
                    textureKey = data.textures.top;
                } else {
                    textureKey = Object.values(data.textures)[0];
                }
                
                blockOption.style.backgroundImage = `url(${textureURLs[textureKey]})`;
                
                if (type === selectedBlockType) {
                    blockOption.classList.add('selected');
                }
                
                blockOption.addEventListener('click', () => {
                    document.querySelectorAll('.block-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    blockOption.classList.add('selected');
                    selectedBlockType = type;
                });
                
                blockSelector.appendChild(blockOption);
            }
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space':
                        if (canJump) {
                            velocity.y = jumpStrength;
                            canJump = false;
                        }
                        break;
                    case 'KeyE':
                        const blockSelector = document.getElementById('blockSelector');
                        blockSelector.style.display = blockSelector.style.display === 'none' ? 'flex' : 'none';
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });
            
            // Mouse click for block interaction
            document.addEventListener('mousedown', (event) => {
                if (!controls.isLocked) return;
                
                // Cast ray from camera
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                
                // Get intersections with blocks
                const intersects = raycaster.intersectObjects(Object.values(world));
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const block = intersect.object;
                    
                    if (event.button === 0) {  // Left click - remove block
                        removeBlock(block.userData.x, block.userData.y, block.userData.z);
                    } else if (event.button === 2) {  // Right click - add block
                        // Get the face that was clicked
                        const faceIndex = intersect.faceIndex;
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(block.matrixWorld);
                        const normal = intersect.face.normal.clone().applyMatrix3(normalMatrix).normalize();
                        
                        // Calculate position for new block
                        const x = block.userData.x + normal.x;
                        const y = block.userData.y + normal.y;
                        const z = block.userData.z + normal.z;
                        
                        // Check if position is valid (not inside player)
                        const playerPos = new THREE.Vector3(
                            Math.floor(camera.position.x / cubeSize),
                            Math.floor(camera.position.y / cubeSize),
                            Math.floor(camera.position.z / cubeSize)
                        );
                        
                        const playerHeadPos = new THREE.Vector3(
                            playerPos.x,
                            playerPos.y + 1,
                            playerPos.z
                        );
                        
                        if (x !== playerPos.x || y !== playerPos.y || z !== playerPos.z) {
                            if (x !== playerHeadPos.x || y !== playerHeadPos.y || z !== playerHeadPos.z) {
                                createBlock(x, y, z, selectedBlockType);
                            }
                        }
                    }
                }
            });
            
            // Prevent context menu on right click
            document.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            // Apply gravity
            velocity.y -= gravity * delta;
            
            // Get movement direction
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();
            
            // Calculate velocity based on inputs
            if (moveForward || moveBackward) velocity.z = -direction.z * playerSpeed;
            else velocity.z = 0;
            
            if (moveLeft || moveRight) velocity.x = -direction.x * playerSpeed;
            else velocity.x = 0;
            
            // Apply movement
            controls.moveRight(velocity.x * delta);
            controls.moveForward(velocity.z * delta);
            
            // Apply gravity and check for ground collision
            camera.position.y += velocity.y * delta;
            
            // Check collision with ground
            const playerPos = new THREE.Vector3(
                Math.floor(camera.position.x / cubeSize),
                Math.floor((camera.position.y - playerHeight/2) / cubeSize),
                Math.floor(camera.position.z / cubeSize)
            );
            
            // Check if block exists below player
            const blockBelow = world[`${playerPos.x},${playerPos.y - 1},${playerPos.z}`];
            
            if (blockBelow && camera.position.y - playerHeight/2 <= (playerPos.y * cubeSize + cubeSize)) {
                velocity.y = 0;
                camera.position.y = playerPos.y * cubeSize + cubeSize + playerHeight/2;
                canJump = true;
            }
            
            // Prevent falling through the world
            if (camera.position.y < -50) {
                camera.position.set(0, 50, 0);
                velocity.set(0, 0, 0);
            }
            
            // Update HUD
            document.getElementById('position').textContent = 
                `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
            
            // Render scene
            renderer.render(scene, camera);
            
            prevTime = time;
        }
        
        // Start the game
        init();
    </script>
</body>
</html>
